<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PBuf: Theory of operation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PBuf
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">Priority Buffer</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_docs_dox_theory_of_operation.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Theory of operation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a description of the theory of operation of <em>PBuf</em>.</p>
<h2>Configuration</h2>
<p><em>PBuf</em> is configured at compile time by setting a small number of defines in <a class="el" href="priority__buffer_8h.html">priority_buffer.h</a>:</p>
<div class="fragment"><div class="line">#define BUFFER_SIZE 4      /* may be between 4 to 256 elements in size */</div><div class="line"></div><div class="line">#define PRIORITY_SIZE 3    /* may be between 2 to 8 priorities in size */</div><div class="line"></div><div class="line">#define ELEMENT_SIZE 8     /* may be either 8, 16, 32, or 64 bits */</div><div class="line"></div><div class="line">#define EXTERNAL_DATA_BUFFER   /* Enable headless mode if defined */</div></div><!-- fragment --><p>The compiler checks these settings at compile time and compile will fail if they are out of limits.</p>
<p>These settings may also be provided on the command line to the compiler such as <code>-DELEMENT_SIZE=8</code></p>
<p><a class="el" href="priority__buffer_8h.html">priority_buffer.h</a> is purposefully kept very minimal to highlight these user configurations.</p>
<h2>Design choice</h2>
<p>The design is optimised for smaller embedded devices, and should be suitable down to 8-bit devices.</p>
<h2>Requirement Assumptions</h2>
<p>Due to the nature and size of the project it was decided to push through a design and then refactor for any wrong assumptions in the design and implementation. The design is unit-tested to ensure this refactoring is as painless as possible.</p>
<h2>Memory</h2>
<p>The circular buffer is a structure containing elements upto the defined <code>BUFFER_SIZE</code>. Each element is a structure containing both data and a forward-linking link to the following buffer location.</p>
<p>We also have a tail pointer and and array of head pointers whose size is equal to the <code>PRIORITY_SIZE</code>. In addition, a further byte is used to store active flags for each priority.</p>
<p>With these pointers into the structure we can process both insert and retrieve operations very quickly. The only time we spend following the links to any extent (beyond one or two) is when we are requred to calculate the size of the buffer contents since it was decided the memory saved here was justifiable (the print function also follows the links, but this is a <code>DEBUG</code> enabled function only - for the purpose of the command line evaluation program).</p>
<h2>Headless Operation</h2>
<p><em>PBuf</em> can be used in a headless mode where the user supplies the buffer, and configures PBUF appropriately. In this configuration the commands <code><a class="el" href="group__API.html#gad469c993773b10f11dc9f8368808fc04" title="Insert index of the given priority is passed to by modifying index. ">PBUF_insertIndex()</a></code> and <code><a class="el" href="group__API.html#ga4f18ccb6b9c8c71c0b13c6ff3b38b0a0" title="Retrieve index is passed to the caller by modifying index. ">PBUF_retrieveIndex()</a></code> are used to have <em>PBuf</em> figure out the appropriate indices to reference the remote buffer correctly. This mode is achieved by defining <code>EXTERNAL_DATA_BUFFER</code>, which causes the compiler to build <em>PBuf</em> without the internal buffer storage or the buffer manipulation instruction <code><a class="el" href="group__API.html#ga9d1b9e336494e7121aeb2d33790e8778" title="Insert data into the buffer of the given priority. ">PBUF_insert()</a></code> and <code><a class="el" href="group__API.html#ga3b29980e7f7f1d7adbc8c01d14ea3c56" title="Retrieve an element from the tail of the buffer and assign to the element pointer passed in...">PBUF_retrieve()</a></code>.</p>
<h2>Pointers</h2>
<p>As mentioned, a number of pointers are used to provide fast access into the buffer:</p>
<p>Here P2 refers to highest priority, P0 to lowest priority etc. Tail is the tail pointer. Head is the head pointer. The active array maintains the active status. the x denotes an empty element.</p>
<div class="fragment"><div class="line">---------------------&lt;------------------</div><div class="line">|                                      |</div><div class="line">-&gt;  P2   -&gt;   P1   -&gt;   P0   -&gt;   x   &gt;-</div><div class="line">    ^         ^         ^         ^</div><div class="line"> Head[2]   Head[1]   Head[0]     Tail</div><div class="line"></div><div class="line">Active[1] = ACTIVE</div><div class="line">Active[2] = ACTIVE</div><div class="line">Active[3] = ACTIVE</div></div><!-- fragment --><h2>Retrieving Data</h2>
<p>To retrieve an element the tail updates by following the link of the element it refernces, and the data at its new position is retrieved. If the head pointer matching the retrieved element's priority has the same index value as the tail pointer, the relevant active flag is set to <code>NON_ACTIVE</code>.</p>
<p>If there is no data in the buffer all active flags are <code>NON_ACTIVE</code> and a suitable message returned to the caller. The empty buffer check is a single instruction operation.</p>
<h2>Adding Data</h2>
<p>Since we prioritise the data added to the buffer the direction of priorities can be considered as flowing away from the tail from oldest high priority through newest high priority all the way down to oldest low priority through to newest low priority. This means that data is always retrieved highest priority first but in a first- in-first-out manner considering the priority.</p>
<p>Elements are added to the buffer by the following means:</p>
<h3>Buffer Empty</h3>
<p>If the buffer is empty, we add data to the location linked by the tail pointer. We ensure the data's priority is noted on the relevant active flag, and assign the relevant priority head pointer with the array index of the element's position in the buffer. In this way the priority head pointers always point to the newest element having that priority. If any active flag is <code>INACTIVE</code> the associated head pointer's data is contains a meaningless value.</p>
<h3>Buffer containing data but not full</h3>
<p>If the buffer is neither empty nor full, we add data to the location with the least highest priority. This is simply the index value of the lowest active priority pointer. In this case the data may be of a higher priority than its predecesser in which case we need to move it to the correct position. This is dealt with below by remapping the buffer.</p>
<h3>Buffer Full</h3>
<p>If the buffer is full we need to determine if there is older data we can overwrite rather than throwing away this new data. This is achieved by the following strategy:</p>
<p>If there is data in the buffer having a priority that is either equal or of a lesser priority then we pick the lowest priority, and the oldest entry within that priority. We can reference this value by examining the priority head pointers and picking the next highest active priority to the one we want and following its link. This is where we need to overwrite our new data. It may happen that there is no higher priority active in which case our location is linked to by the value of the tail pointer index. Once we've overwritten the older data we will need to rearrange our links to relocate the latest entry to be at the end of it's queue of identical priority. This is described below.</p>
<h2>Remapping the buffer</h2>
<p>When data of varying priorities are added to the buffer we then need to rearrange the buffer to place the new element at the correct position in the buffer relevant to its priority. We are only concerned with remapping a single element since this is what we added, and the operation is very simple and quick.</p>
<p>NOTE: This process is described more thoroughly in the <code>adding_data_to_the_buffer</code> document. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
