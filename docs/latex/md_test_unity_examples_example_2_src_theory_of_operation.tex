This is a description of the theory of operation of this prioritorised circular buffer.

\subsection*{Configuration}

The buffer is configured at compile time by setting a small number of defines in priority\+\_\+buffer.\+h\+:

\#define B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE 4 /$\ast$ may be between 4 to 256 elements in size $\ast$/

\#define P\+R\+I\+O\+R\+I\+T\+Y\+\_\+\+S\+I\+ZE 3 /$\ast$ may be between 2 to 8 priorities in size $\ast$/

// \#define E\+L\+E\+M\+E\+N\+T\+\_\+\+S\+I\+ZE 8 /$\ast$ may be either 8, 16, 32, or 64 bits $\ast$/

The compiler checks these settings at compile time and compile will fail if they are out of limits.

These settings may also be provided on the command line to the compiler such as -\/\+D\+E\+L\+E\+M\+E\+N\+T\+\_\+\+S\+I\+ZE=8

priority\+\_\+buffer.\+h is purposefully kept very minimal to highlight these user configurations.

\subsection*{Design choice}

The design is optimised for smaller embedded devices, and should be suitable down to 8-\/bit devices.

\subsection*{Requirement Assumptions}

Due to the nature and size of the project it was decided to push through a design and then refactor for any wrong assumptions in the design and implementation. The design is unit-\/tested to ensure this refactoring is as painless as possible.

\subsection*{Memory}

The circular buffer is a structure containing elements upto the defined B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE. Each element is a structure containing both data and a forward-\/linking link to the following buffer location.

We also have a tail pointer and and array of head pointers whose size is equal to the P\+R\+I\+O\+R\+I\+T\+Y\+\_\+\+S\+I\+ZE. In addition, a further byte is used to store active flags for each priority.

With these pointers into the structure we can process both insert and retrieve operations very quickly. The only time we spend following the links to any extent (beyond one or two) is when we are requred to calculate the size of the buffer contents since it was decided the memory saved here was justifiable (the print function also follows the links, but this is a D\+E\+B\+UG enabled function only -\/ for the purpose of the command line evaluation program).

\subsection*{Pointers}

As mentioned, a number of pointers are used to provide fast access into the buffer\+:

1) Here P1 refers to highest priority, P3 to lowest priority etc. Tail is the tail pointer. Head is the head pointer. The active array maintains the active status. the x denotes an empty element.

-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---$<$-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- $\vert$ $\vert$ -\/$>$ P1 -\/$>$ P2 -\/$>$ P3 -\/$>$ x $>$-\/ $^\wedge$ $^\wedge$ $^\wedge$ $^\wedge$ Head\mbox{[}1\mbox{]} Head\mbox{[}2\mbox{]} Head\mbox{[}3\mbox{]} Tail

Active\mbox{[}1\mbox{]} = A\+C\+T\+I\+VE Active\mbox{[}2\mbox{]} = A\+C\+T\+I\+VE Active\mbox{[}3\mbox{]} = A\+C\+T\+I\+VE

\subsection*{Retrieving Data}

To retrieve an element the tail updates by following the link of the element it refernces, and the data at its new position is retrieved. If the head pointer matching the retrieved element\textquotesingle{}s priority has the same index value as the tail pointer, the relevant active flag is set to N\+O\+N\+\_\+\+A\+C\+T\+I\+VE.

If there is no data in the buffer all active flags are N\+O\+N\+\_\+\+A\+C\+T\+I\+VE and a suitable message returned to the caller. The empty buffer check is a single instruction operation.

\subsection*{Adding Data}

Since we prioritise the data added to the buffer the direction of priorities can be considered as flowing away from the tail from oldest high priority through newest high priority all the way down to oldest low priority through to newest low priority. This means that data is always retrieved highest priority first but in a first-\/ in-\/first-\/out manner considering the priority.

Elements are added to the buffer by the following means\+:

\subsubsection*{Buffer Empty}

If the buffer is empty, we add data to the location linked by the tail pointer. We ensure the data\textquotesingle{}s priority is noted on the relevant active flag, and assign the relevant priority head pointer with the array index of the element\textquotesingle{}s position in the buffer. In this way the priority head pointers always point to the newest element having that priority. If any active flag is I\+N\+A\+C\+T\+I\+VE the associated head pointer\textquotesingle{}s data is contains a meaningless value.

\subsubsection*{Buffer containing data but not full}

If the buffer is neither empty nor full, we add data to the location referenced by the `virtual master head\textquotesingle{} pointer. This is simply the index value of the lowest active priority pointer. In this case the data may be of a higher priority than its predecesser in which case we need to move it to the correct position. This is dealt with below by remapping the buffer.

\subsubsection*{Buffer Full}

If the buffer is full we need to determine if there is older data we can overwrite rather than throwing away this new data. This is achieved by the following strategy\+:

If there is data in the buffer having a priority that is either equal or of a lesser priority then we pick the lowest priority, and the oldest entry within that priority. We can reference this value by examining the priority head pointers and picking the next highest active priority to the one we want and following its link. This is where we need to overwrite our new data. It may happen that there is no higher priority active in which case our location is linked to by the value of the tail pointer index. Once we\textquotesingle{}ve overwritten the older data we will need to rearrange our links to relocate the latest entry to be at the end of it\textquotesingle{}s queue of identical priority. This is described below.

\subsection*{Remapping the buffer}

When data of varying priorities are added to the buffer we then need to rearrange the buffer to place the new element at the correct position in the buffer relevant to its priority. We are only concerned with remapping a single element since this is what we added, and the operation is very simple and quick. 